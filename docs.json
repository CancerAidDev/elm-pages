[{"name":"DataSource","comment":" StaticHttp requests are an alternative to doing Elm HTTP requests the traditional way using the `elm/http` package.\n\nThe key differences are:\n\n  - `StaticHttp.Request`s are performed once at build time (`Http.Request`s are performed at runtime, at whenever point you perform them)\n  - `StaticHttp.Request`s strip out unused JSON data from the data your decoder doesn't touch to minimize the JSON payload\n  - `StaticHttp.Request`s can use [`Pages.Secrets`](Pages.Secrets) to securely use credentials from your environment variables which are completely masked in the production assets.\n  - `StaticHttp.Request`s have a built-in `StaticHttp.andThen` that allows you to perform follow-up requests without using tasks\n\n\n## Scenarios where StaticHttp is a good fit\n\nIf you need data that is refreshed often you may want to do a traditional HTTP request with the `elm/http` package.\nThe kinds of situations that are served well by static HTTP are with data that updates moderately frequently or infrequently (or never).\nA common pattern is to trigger a new build when data changes. Many JAMstack services\nallow you to send a WebHook to your host (for example, Netlify is a good static file host that supports triggering builds with webhooks). So\nyou may want to have your site rebuild everytime your calendar feed has an event added, or whenever a page or article is added\nor updated on a CMS service like Contentful.\n\nIn scenarios like this, you can serve data that is just as up-to-date as it would be using `elm/http`, but you get the performance\ngains of using `StaticHttp.Request`s as well as the simplicity and robustness that comes with it. Read more about these benefits\nin [this article introducing StaticHttp requests and some concepts around it](https://elm-pages.com/blog/static-http).\n\n\n## Scenarios where StaticHttp is not a good fit\n\n  - Data that is specific to the logged-in user\n  - Data that needs to be the very latest and changes often (for example, sports scores)\n\n@docs DataSource\n\n@docs map, succeed, fail\n\n@docs fromResult\n\n\n## Building a StaticHttp Request Body\n\nThe way you build a body is analogous to the `elm/http` package. Currently, only `emptyBody` and\n`stringBody` are supported. If you have a use case that calls for a different body type, please open a Github issue\nand describe your use case!\n\n@docs Body, emptyBody, stringBody, jsonBody\n\n\n## Chaining Requests\n\n@docs andThen, resolve, combine\n\n@docs map2, map3, map4, map5, map6, map7, map8, map9\n\n","unions":[],"aliases":[{"name":"Body","comment":" A body for a StaticHttp request.\n","args":[],"type":"Pages.Internal.StaticHttpBody.Body"},{"name":"DataSource","comment":" A DataSource represents data that will be gathered at build time. Multiple `DataSource`s can be combined together using the `mapN` functions,\nvery similar to how you can manipulate values with Json Decoders in Elm.\n","args":["value"],"type":"Pages.StaticHttpRequest.RawRequest value"}],"values":[{"name":"andThen","comment":" Build off of the response from a previous `StaticHttp` request to build a follow-up request. You can use the data\nfrom the previous response to build up the URL, headers, etc. that you send to the subsequent request.\n\n    import DataSource\n    import Json.Decode as Decode exposing (Decoder)\n\n    licenseData : StaticHttp.Request String\n    licenseData =\n        StaticHttp.get\n            (Secrets.succeed \"https://api.github.com/repos/dillonkearns/elm-pages\")\n            (Decode.at [ \"license\", \"url\" ] Decode.string)\n            |> StaticHttp.andThen\n                (\\licenseUrl ->\n                    StaticHttp.get (Secrets.succeed licenseUrl) (Decode.field \"description\" Decode.string)\n                )\n\n","type":"(a -> DataSource.DataSource b) -> DataSource.DataSource a -> DataSource.DataSource b"},{"name":"combine","comment":" Turn a list of `StaticHttp.Request`s into a single one.\n\n    import DataSource\n    import Json.Decode as Decode exposing (Decoder)\n\n    type alias Pokemon =\n        { name : String\n        , sprite : String\n        }\n\n    pokemonDetailRequest : StaticHttp.Request (List Pokemon)\n    pokemonDetailRequest =\n        StaticHttp.get\n            (Secrets.succeed \"https://pokeapi.co/api/v2/pokemon/?limit=3\")\n            (Decode.field \"results\"\n                (Decode.list\n                    (Decode.map2 Tuple.pair\n                        (Decode.field \"name\" Decode.string)\n                        (Decode.field \"url\" Decode.string)\n                        |> Decode.map\n                            (\\( name, url ) ->\n                                StaticHttp.get (Secrets.succeed url)\n                                    (Decode.at\n                                        [ \"sprites\", \"front_default\" ]\n                                        Decode.string\n                                        |> Decode.map (Pokemon name)\n                                    )\n                            )\n                    )\n                )\n            )\n            |> StaticHttp.andThen StaticHttp.combine\n\n","type":"List.List (DataSource.DataSource value) -> DataSource.DataSource (List.List value)"},{"name":"emptyBody","comment":" Build an empty body for a StaticHttp request. See [elm/http's `Http.emptyBody`](https://package.elm-lang.org/packages/elm/http/latest/Http#emptyBody).\n","type":"DataSource.Body"},{"name":"fail","comment":" Stop the StaticHttp chain with the given error message. If you reach a `fail` in your request,\nyou will get a build error. Or in the dev server, you will see the error message in an overlay in your browser (and in\nthe terminal).\n","type":"String.String -> DataSource.DataSource a"},{"name":"fromResult","comment":" Turn an Err into a DataSource failure.\n","type":"Result.Result String.String value -> DataSource.DataSource value"},{"name":"jsonBody","comment":" Builds a JSON body for a StaticHttp request. See [elm/http's `Http.jsonBody`](https://package.elm-lang.org/packages/elm/http/latest/Http#jsonBody).\n","type":"Json.Encode.Value -> DataSource.Body"},{"name":"map","comment":" Transform a request into an arbitrary value. The same underlying HTTP requests will be performed during the build\nstep, but mapping allows you to change the resulting values by applying functions to the results.\n\nA common use for this is to map your data into your elm-pages view:\n\n    import DataSource\n    import Json.Decode as Decode exposing (Decoder)\n\n    view =\n        StaticHttp.get\n            (Secrets.succeed \"https://api.github.com/repos/dillonkearns/elm-pages\")\n            (Decode.field \"stargazers_count\" Decode.int)\n            |> StaticHttp.map\n                (\\stars ->\n                    { view =\n                        \\model viewForPage ->\n                            { title = \"Current stars: \" ++ String.fromInt stars\n                            , body = Html.text <| \"⭐️ \" ++ String.fromInt stars\n                            , head = []\n                            }\n                    }\n                )\n\n","type":"(a -> b) -> DataSource.DataSource a -> DataSource.DataSource b"},{"name":"map2","comment":" Like map, but it takes in two `Request`s.\n\n    view siteMetadata page =\n        StaticHttp.map2\n            (\\elmPagesStars elmMarkdownStars ->\n                { view =\n                    \\model viewForPage ->\n                        { title = \"Repo Stargazers\"\n                        , body = starsView elmPagesStars elmMarkdownStars\n                        }\n                , head = head elmPagesStars elmMarkdownStars\n                }\n            )\n            (get\n                (Secrets.succeed \"https://api.github.com/repos/dillonkearns/elm-pages\")\n                (Decode.field \"stargazers_count\" Decode.int)\n            )\n            (get\n                (Secrets.succeed \"https://api.github.com/repos/dillonkearns/elm-markdown\")\n                (Decode.field \"stargazers_count\" Decode.int)\n            )\n\n","type":"(a -> b -> c) -> DataSource.DataSource a -> DataSource.DataSource b -> DataSource.DataSource c"},{"name":"map3","comment":" ","type":"(value1 -> value2 -> value3 -> valueCombined) -> DataSource.DataSource value1 -> DataSource.DataSource value2 -> DataSource.DataSource value3 -> DataSource.DataSource valueCombined"},{"name":"map4","comment":" ","type":"(value1 -> value2 -> value3 -> value4 -> valueCombined) -> DataSource.DataSource value1 -> DataSource.DataSource value2 -> DataSource.DataSource value3 -> DataSource.DataSource value4 -> DataSource.DataSource valueCombined"},{"name":"map5","comment":" ","type":"(value1 -> value2 -> value3 -> value4 -> value5 -> valueCombined) -> DataSource.DataSource value1 -> DataSource.DataSource value2 -> DataSource.DataSource value3 -> DataSource.DataSource value4 -> DataSource.DataSource value5 -> DataSource.DataSource valueCombined"},{"name":"map6","comment":" ","type":"(value1 -> value2 -> value3 -> value4 -> value5 -> value6 -> valueCombined) -> DataSource.DataSource value1 -> DataSource.DataSource value2 -> DataSource.DataSource value3 -> DataSource.DataSource value4 -> DataSource.DataSource value5 -> DataSource.DataSource value6 -> DataSource.DataSource valueCombined"},{"name":"map7","comment":" ","type":"(value1 -> value2 -> value3 -> value4 -> value5 -> value6 -> value7 -> valueCombined) -> DataSource.DataSource value1 -> DataSource.DataSource value2 -> DataSource.DataSource value3 -> DataSource.DataSource value4 -> DataSource.DataSource value5 -> DataSource.DataSource value6 -> DataSource.DataSource value7 -> DataSource.DataSource valueCombined"},{"name":"map8","comment":" ","type":"(value1 -> value2 -> value3 -> value4 -> value5 -> value6 -> value7 -> value8 -> valueCombined) -> DataSource.DataSource value1 -> DataSource.DataSource value2 -> DataSource.DataSource value3 -> DataSource.DataSource value4 -> DataSource.DataSource value5 -> DataSource.DataSource value6 -> DataSource.DataSource value7 -> DataSource.DataSource value8 -> DataSource.DataSource valueCombined"},{"name":"map9","comment":" ","type":"(value1 -> value2 -> value3 -> value4 -> value5 -> value6 -> value7 -> value8 -> value9 -> valueCombined) -> DataSource.DataSource value1 -> DataSource.DataSource value2 -> DataSource.DataSource value3 -> DataSource.DataSource value4 -> DataSource.DataSource value5 -> DataSource.DataSource value6 -> DataSource.DataSource value7 -> DataSource.DataSource value8 -> DataSource.DataSource value9 -> DataSource.DataSource valueCombined"},{"name":"resolve","comment":" Helper to remove an inner layer of Request wrapping.\n","type":"DataSource.DataSource (List.List (DataSource.DataSource value)) -> DataSource.DataSource (List.List value)"},{"name":"stringBody","comment":" Builds a string body for a StaticHttp request. See [elm/http's `Http.stringBody`](https://package.elm-lang.org/packages/elm/http/latest/Http#stringBody).\n\nNote from the `elm/http` docs:\n\n> The first argument is a [MIME type](https://en.wikipedia.org/wiki/Media_type) of the body. Some servers are strict about this!\n\n","type":"String.String -> String.String -> DataSource.Body"},{"name":"succeed","comment":" This is useful for prototyping with some hardcoded data, or for having a view that doesn't have any StaticHttp data.\n\n    import DataSource\n\n    view :\n        List ( PagePath, Metadata )\n        ->\n            { path : PagePath\n            , frontmatter : Metadata\n            }\n        ->\n            StaticHttp.Request\n                { view : Model -> View -> { title : String, body : Html Msg }\n                , head : List (Head.Tag Pages.PathKey)\n                }\n    view siteMetadata page =\n        StaticHttp.succeed\n            { view =\n                \\model viewForPage ->\n                    mainView model viewForPage\n            , head = head page.frontmatter\n            }\n\n","type":"a -> DataSource.DataSource a"}],"binops":[]},{"name":"DataSource.File","comment":"\n\n@docs body, frontmatter, glob, rawFile, request\n\n","unions":[],"aliases":[],"values":[{"name":"body","comment":" ","type":"OptimizedDecoder.Decoder String.String"},{"name":"frontmatter","comment":" ","type":"OptimizedDecoder.Decoder frontmatter -> OptimizedDecoder.Decoder frontmatter"},{"name":"glob","comment":" ","type":"String.String -> DataSource.DataSource (List.List String.String)"},{"name":"rawFile","comment":" ","type":"OptimizedDecoder.Decoder String.String"},{"name":"request","comment":" ","type":"String.String -> OptimizedDecoder.Decoder a -> DataSource.DataSource a"}],"binops":[]},{"name":"DataSource.Glob","comment":"\n\n@docs Glob\n\nThis module helps you get a List of matching file paths from your local file system as a `DataSource`. See the `DataSource` module documentation\nfor ways you can combine and map `DataSource`s.\n\nA common example would be to find all the markdown files of your blog posts. If you have all your blog posts in `content/blog/*.md`\n, then you could use that glob pattern in most shells to refer to each of those files.\n\nWith the `DataSource.Glob` API, you could get all of those files like so:\n\n    import DataSource exposing (DataSource)\n\n    blogPostsGlob : DataSource (List String)\n    blogPostsGlob =\n        Glob.succeed (\\slug -> slug)\n            |> Glob.match (Glob.literal \"content/blog/\")\n            |> Glob.capture Glob.wildcard\n            |> Glob.match (Glob.literal \".md\")\n            |> Glob.toDataSource\n\nLet's say you have these files locally:\n\n```shell\n- elm.json\n- src/\n- content/\n  - blog/\n    - first-post.md\n    - second-post.md\n```\n\nWe would end up with a `DataSource` like this:\n\n    DataSource.succeed [ \"first-post\", \"second-post\" ]\n\nOf course, if you add or remove matching files, the DataSource will get those new files (unlike `DataSource.succeed`). That's why we have Glob!\n\nYou can even see the `elm-pages dev` server will automatically flow through any added/removed matching files with its hot module reloading.\n\nBut why did we get `\"first-post\"` instead of a full file path, like `\"content/blog/first-post.md\"`? That's the difference between\n`capture` and `match`.\n\n\n## Capture and Match\n\nThere are two functions for building up a Glob pattern. `capture` and `match`.\n\nWhether you use `capture` or `match`, the actual file paths that match the glob you build will not change. It's only the resulting\nElm value you get from each matching file that will depend on `capture` or `match`.\n\n@docs capture, match\n\n`capture` is a lot like building up a JSON decoder with a pipeline.\n\nLet's try our blogPostsGlob from before, but change every `match` to `capture`.\n\n    import DataSource exposing (DataSource)\n\n    blogPostsGlob :\n        DataSource\n            (List\n                { filePath : String\n                , slug : String\n                }\n            )\n    blogPostsGlob =\n        Glob.succeed\n            (\\capture1 capture2 capture3 ->\n                { filePath = capture1 ++ capture2 ++ capture3\n                , slug = capture2\n                }\n            )\n            |> Glob.capture (Glob.literal \"content/blog/\")\n            |> Glob.capture Glob.wildcard\n            |> Glob.capture (Glob.literal \".md\")\n            |> Glob.toDataSource\n\nNotice that we now need 3 arguments at the start of our pipeline instead of 1. That's because\nwe apply 1 more argument every time we do a `Glob.capture`, much like `Json.Decode.Pipeline.required`, or other pipeline APIs.\n\nNow we actually have the full file path of our files. But having that slug (like `first-post`) is also very helpful sometimes, so\nwe kept that in our record as well. So we'll now have the equivalent of this `DataSource` with the current `.md` files in our `blog` folder:\n\n    DataSource.succeed\n        [ { filePath = \"content/blog/first-post.md\"\n          , slug = \"first-post\"\n          }\n        , { filePath = \"content/blog/second-post.md\"\n          , slug = \"second-post\"\n          }\n        ]\n\nHaving the full file path lets us read in files. But concatenating it manually is tedious\nand error prone. That's what the `captureFilePath` helper is for.\n\n\n## Reading matching files\n\n@docs captureFilePath\n\n    import DataSource exposing (DataSource)\n\n    blogPosts :\n        DataSource\n            (List\n                { filePath : String\n                , slug : String\n                }\n            )\n    blogPosts =\n        Glob.succeed\n            (\\filePath slug ->\n                { filePath = filePath\n                , slug = slug\n                }\n            )\n            |> Glob.captureFilePath\n            |> Glob.match (Glob.literal \"content/blog/\")\n            |> Glob.capture Glob.wildcard\n            |> Glob.match (Glob.literal \".md\")\n            |> Glob.toDataSource\n\nIn many cases you will want to use a `Glob` `DataSource`, and then read the body or frontmatter from matching files.\n\n\n## Reading Metadata for each Glob Match\n\nFor example, if we had files like this:\n\n```markdown\n---\ntitle: My First Post\n---\nThis is my first post!\n```\n\nThen we could read that title for our blog post list page using our `blogPosts` `DataSource` that we defined above.\n\n    import DataSource.File\n    import OptimizedDecoder as Decode exposing (Decoder)\n\n    titles : DataSource (List BlogPost)\n    titles =\n        blogPosts\n            |> DataSource.map\n                (List.map\n                    (\\blogPost ->\n                        DataSource.File.request\n                            blogPost.filePath\n                            (DataSource.File.frontmatter blogFrontmatterDecoder)\n                    )\n                )\n            |> DataSource.resolve\n\n    type alias BlogPost =\n        { title : String }\n\n    blogFrontmatterDecoder : Decoder BlogPost\n    blogFrontmatterDecoder =\n        Decode.map BlogPost\n            (Decode.field \"title\" Decode.string)\n\nThat will give us\n\n    DataSource.succeed\n        [ { title = \"My First Post\" }\n        , { title = \"My Second Post\" }\n        ]\n\n\n## Capturing Patterns\n\n@docs wildcard, recursiveWildcard, int\n\n\n## Matching a Specific Number of Files\n\n@docs expectUniqueFile\n\n\n## Glob Patterns\n\n@docs literal\n\n@docs atLeastOne, map, oneOf, succeed, toDataSource, zeroOrMore\n\n\n## Is this useful/used?\n\n@docs toNonEmptyWithDefault\n\n\n## Internals - TODO Remove\n\n@docs run, extractMatches\n\n","unions":[{"name":"Glob","comment":" ","args":["a"],"cases":[]}],"aliases":[],"values":[{"name":"atLeastOne","comment":" ","type":"( ( String.String, a ), List.List ( String.String, a ) ) -> DataSource.Glob.Glob ( a, List.List a )"},{"name":"capture","comment":" ","type":"DataSource.Glob.Glob a -> DataSource.Glob.Glob (a -> value) -> DataSource.Glob.Glob value"},{"name":"captureFilePath","comment":" ","type":"DataSource.Glob.Glob (String.String -> value) -> DataSource.Glob.Glob value"},{"name":"expectUniqueFile","comment":" ","type":"DataSource.Glob.Glob a -> DataSource.DataSource String.String"},{"name":"extractMatches","comment":" ","type":"a -> List.List ( String.String, a ) -> String.String -> List.List a"},{"name":"int","comment":" ","type":"DataSource.Glob.Glob Basics.Int"},{"name":"literal","comment":" ","type":"String.String -> DataSource.Glob.Glob String.String"},{"name":"map","comment":" ","type":"(a -> b) -> DataSource.Glob.Glob a -> DataSource.Glob.Glob b"},{"name":"match","comment":" ","type":"DataSource.Glob.Glob a -> DataSource.Glob.Glob value -> DataSource.Glob.Glob value"},{"name":"oneOf","comment":"\n\n    import DataSource.Glob as Glob\n\n    type Extension\n        = Json\n        | Yml\n\n    type alias DataFile =\n        { name : String\n        , extension : String\n        }\n\n    dataFiles : DataSource (List DataFile)\n    dataFiles =\n        Glob.succeed DataFile\n            |> Glob.match (Glob.literal \"my-data/\")\n            |> Glob.capture Glob.wildcard\n            |> Glob.match (Glob.literal \".\")\n            |> Glob.capture\n                (Glob.oneOf\n                    ( ( \"yml\", Yml )\n                    , [ ( \"json\", Json )\n                      ]\n                    )\n                )\n\nIf we have the following files\n\n```shell\n- my-data/\n    - authors.yml\n    - events.json\n```\n\nThat gives us\n\n    results : DataSource (List DataFile)\n    results =\n        DataSource.succeed\n            [ { name = \"authors\"\n              , extension = Yml\n              }\n            , { name = \"events\"\n              , extension = Json\n              }\n            ]\n\nYou could also match an optional file path segment using `oneOf`.\n\n    rootFilesMd : DataSource (List String)\n    rootFilesMd =\n        Glob.succeed (\\slug -> slug)\n            |> Glob.match (Glob.literal \"blog/\")\n            |> Glob.capture Glob.wildcard\n            |> Glob.match\n                (Glob.oneOf\n                    ( ( \"\", () )\n                    , [ ( \"/index\", () ) ]\n                    )\n                )\n            |> Glob.match (Glob.literal \".md\")\n            |> Glob.toDataSource\n\nWith these files:\n\n```markdown\n- blog/\n    - first-post.md\n    - second-post/\n        - index.md\n```\n\nThis would give us:\n\n    results : DataSource (List String)\n    results =\n        DataSource.succeed\n            [ \"first-post\"\n            , \"second-post\"\n            ]\n\n","type":"( ( String.String, a ), List.List ( String.String, a ) ) -> DataSource.Glob.Glob a"},{"name":"recursiveWildcard","comment":" ","type":"DataSource.Glob.Glob (List.List String.String)"},{"name":"run","comment":" ","type":"String.String -> DataSource.Glob.Glob a -> { match : a, pattern : String.String }"},{"name":"succeed","comment":" ","type":"constructor -> DataSource.Glob.Glob constructor"},{"name":"toDataSource","comment":" ","type":"DataSource.Glob.Glob a -> DataSource.DataSource (List.List a)"},{"name":"toNonEmptyWithDefault","comment":" ","type":"a -> List.List a -> ( a, List.List a )"},{"name":"wildcard","comment":" ","type":"DataSource.Glob.Glob String.String"},{"name":"zeroOrMore","comment":" ","type":"List.List String.String -> DataSource.Glob.Glob (Maybe.Maybe String.String)"}],"binops":[]},{"name":"DataSource.Http","comment":" StaticHttp requests are an alternative to doing Elm HTTP requests the traditional way using the `elm/http` package.\n\nThe key differences are:\n\n  - `StaticHttp.Request`s are performed once at build time (`Http.Request`s are performed at runtime, at whenever point you perform them)\n  - `StaticHttp.Request`s strip out unused JSON data from the data your decoder doesn't touch to minimize the JSON payload\n  - `StaticHttp.Request`s can use [`Pages.Secrets`](Pages.Secrets) to securely use credentials from your environment variables which are completely masked in the production assets.\n  - `StaticHttp.Request`s have a built-in `StaticHttp.andThen` that allows you to perform follow-up requests without using tasks\n\n\n## Scenarios where StaticHttp is a good fit\n\nIf you need data that is refreshed often you may want to do a traditional HTTP request with the `elm/http` package.\nThe kinds of situations that are served well by static HTTP are with data that updates moderately frequently or infrequently (or never).\nA common pattern is to trigger a new build when data changes. Many JAMstack services\nallow you to send a WebHook to your host (for example, Netlify is a good static file host that supports triggering builds with webhooks). So\nyou may want to have your site rebuild everytime your calendar feed has an event added, or whenever a page or article is added\nor updated on a CMS service like Contentful.\n\nIn scenarios like this, you can serve data that is just as up-to-date as it would be using `elm/http`, but you get the performance\ngains of using `StaticHttp.Request`s as well as the simplicity and robustness that comes with it. Read more about these benefits\nin [this article introducing StaticHttp requests and some concepts around it](https://elm-pages.com/blog/static-http).\n\n\n## Scenarios where StaticHttp is not a good fit\n\n  - Data that is specific to the logged-in user\n  - Data that needs to be the very latest and changes often (for example, sports scores)\n\n@docs RequestDetails\n@docs get, request\n\n\n## Building a StaticHttp Request Body\n\nThe way you build a body is analogous to the `elm/http` package. Currently, only `emptyBody` and\n`stringBody` are supported. If you have a use case that calls for a different body type, please open a Github issue\nand describe your use case!\n\n@docs Body, emptyBody, stringBody, jsonBody\n\n\n## Unoptimized Requests\n\nWarning - use these at your own risk! It's highly recommended that you use the other request functions that make use of\n`zwilias/json-decode-exploration` in order to allow you to reduce down your JSON to only the values that are used by\nyour decoders. This can significantly reduce download sizes for your StaticHttp requests.\n\n@docs unoptimizedRequest\n\n\n### Expect for unoptimized requests\n\n@docs Expect, expectString, expectUnoptimizedJson\n\n","unions":[{"name":"Expect","comment":" Analgous to the `Expect` type in the `elm/http` package. This represents how you will process the data that comes\nback in your StaticHttp request.\n\nYou can derive `ExpectUnoptimizedJson` from `ExpectString`. Or you could build your own helper to process the String\nas XML, for example, or give an `elm-pages` build error if the response can't be parsed as XML.\n\n","args":["value"],"cases":[]}],"aliases":[{"name":"Body","comment":" A body for a StaticHttp request.\n","args":[],"type":"Pages.Internal.StaticHttpBody.Body"},{"name":"RequestDetails","comment":" The full details to perform a StaticHttp request.\n","args":[],"type":"{ url : String.String, method : String.String, headers : List.List ( String.String, String.String ), body : DataSource.Http.Body }"}],"values":[{"name":"emptyBody","comment":" Build an empty body for a StaticHttp request. See [elm/http's `Http.emptyBody`](https://package.elm-lang.org/packages/elm/http/latest/Http#emptyBody).\n","type":"DataSource.Http.Body"},{"name":"expectString","comment":" Request a raw String. You can validate the String if you need to check the formatting, or try to parse it\nin something besides JSON. Be sure to use the `StaticHttp.request` function if you want an optimized request that\nstrips out unused JSON to optimize your asset size.\n\nIf the function you pass to `expectString` yields an `Err`, then you will get at StaticHttpDecodingError that will\nfail your `elm-pages` build and print out the String from the `Err`.\n\n    request =\n        StaticHttp.unoptimizedRequest\n            (Secrets.succeed\n                { url = \"https://example.com/file.txt\"\n                , method = \"GET\"\n                , headers = []\n                , body = StaticHttp.emptyBody\n                }\n            )\n            (StaticHttp.expectString\n                (\\string ->\n                    if String.toUpper string == string then\n                        Ok string\n\n                    else\n                        Err \"String was not uppercased\"\n                )\n            )\n\n","type":"(String.String -> Result.Result String.String value) -> DataSource.Http.Expect value"},{"name":"expectUnoptimizedJson","comment":" Handle the incoming response as JSON and don't optimize the asset and strip out unused values.\nBe sure to use the `StaticHttp.request` function if you want an optimized request that\nstrips out unused JSON to optimize your asset size. This function makes sense to use for things like a GraphQL request\nwhere the JSON payload is already trimmed down to the data you explicitly requested.\n\nIf the function you pass to `expectString` yields an `Err`, then you will get at StaticHttpDecodingError that will\nfail your `elm-pages` build and print out the String from the `Err`.\n\n","type":"Json.Decode.Decoder value -> DataSource.Http.Expect value"},{"name":"get","comment":" A simplified helper around [`StaticHttp.request`](#request), which builds up a StaticHttp GET request.\n\n    import DataSource\n    import Json.Decode as Decode exposing (Decoder)\n\n    getRequest : StaticHttp.Request Int\n    getRequest =\n        StaticHttp.get\n            (Secrets.succeed \"https://api.github.com/repos/dillonkearns/elm-pages\")\n            (Decode.field \"stargazers_count\" Decode.int)\n\n","type":"Pages.Secrets.Value String.String -> OptimizedDecoder.Decoder a -> DataSource.DataSource a"},{"name":"jsonBody","comment":" Builds a JSON body for a StaticHttp request. See [elm/http's `Http.jsonBody`](https://package.elm-lang.org/packages/elm/http/latest/Http#jsonBody).\n","type":"Json.Encode.Value -> DataSource.Http.Body"},{"name":"request","comment":" Build a `StaticHttp` request (analagous to [Http.request](https://package.elm-lang.org/packages/elm/http/latest/Http#request)).\nThis function takes in all the details to build a `StaticHttp` request, but you can build your own simplified helper functions\nwith this as a low-level detail, or you can use functions like [StaticHttp.get](#get).\n","type":"Pages.Secrets.Value DataSource.Http.RequestDetails -> OptimizedDecoder.Decoder a -> DataSource.DataSource a"},{"name":"stringBody","comment":" Builds a string body for a StaticHttp request. See [elm/http's `Http.stringBody`](https://package.elm-lang.org/packages/elm/http/latest/Http#stringBody).\n\nNote from the `elm/http` docs:\n\n> The first argument is a [MIME type](https://en.wikipedia.org/wiki/Media_type) of the body. Some servers are strict about this!\n\n","type":"String.String -> String.String -> DataSource.Http.Body"},{"name":"unoptimizedRequest","comment":" This is an alternative to the other request functions in this module that doesn't perform any optimizations on the\nasset. Be sure to use the optimized versions, like `StaticHttp.request`, if you can. Using those can significantly reduce\nyour asset sizes by removing all unused fields from your JSON.\n\nYou may want to use this function instead if you need XML data or plaintext. Or maybe you're hitting a GraphQL API,\nso you don't need any additional optimization as the payload is already reduced down to exactly what you requested.\n\n","type":"Pages.Secrets.Value DataSource.Http.RequestDetails -> DataSource.Http.Expect a -> DataSource.DataSource a"}],"binops":[]},{"name":"Head","comment":" This module contains low-level functions for building up\nvalues that will be rendered into the page's `<head>` tag\nwhen you run `elm-pages build`. Most likely the `Head.Seo` module\nwill do everything you need out of the box, and you will just need to import `Head`\nso you can use the `Tag` type in your type annotations.\n\nBut this module might be useful if you have a special use case, or if you are\nwriting a plugin package to extend `elm-pages`.\n\n@docs Tag, metaName, metaProperty\n@docs rssLink, sitemapLink, rootLanguage\n\n\n## Structured Data\n\n@docs structuredData\n\n\n## `AttributeValue`s\n\n@docs AttributeValue\n@docs currentPageFullUrl, urlAttribute, raw\n\n\n## Icons\n\n@docs appleTouchIcon, icon\n\n\n## Functions for use by generated code\n\n@docs toJson, canonicalLink\n\n","unions":[{"name":"AttributeValue","comment":" Values, such as between the `<>`'s here:\n\n```html\n<meta name=\"<THIS IS A VALUE>\" content=\"<THIS IS A VALUE>\" />\n```\n\n","args":[],"cases":[]},{"name":"Tag","comment":" Values that can be passed to the generated `Pages.application` config\nthrough the `head` function.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"appleTouchIcon","comment":" Note: the type must be png.\nSee <https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html>.\n\nIf a size is provided, it will be turned into square dimensions as per the recommendations here: <https://developers.google.com/web/fundamentals/design-and-ux/browser-customization/#safari>\n\nImages must be png's, and non-transparent images are recommended. Current recommended dimensions are 180px and 192px.\n\n","type":"Maybe.Maybe Basics.Int -> Pages.Url.Url -> Head.Tag"},{"name":"canonicalLink","comment":" It's recommended that you use the `Seo` module helpers, which will provide this\nfor you, rather than directly using this.\n\nExample:\n\n    Head.canonicalLink \"https://elm-pages.com\"\n\n","type":"Maybe.Maybe String.String -> Head.Tag"},{"name":"currentPageFullUrl","comment":" Create an `AttributeValue` representing the current page's full url.\n","type":"Head.AttributeValue"},{"name":"icon","comment":" ","type":"List.List ( Basics.Int, Basics.Int ) -> MimeType.MimeImage -> Pages.Url.Url -> Head.Tag"},{"name":"metaName","comment":" Example:\n\n    metaName\n        [ ( \"name\", \"twitter:card\" )\n        , ( \"content\", \"summary_large_image\" )\n        ]\n\nResults in `<meta name=\"twitter:card\" content=\"summary_large_image\" />`\n\n","type":"String.String -> Head.AttributeValue -> Head.Tag"},{"name":"metaProperty","comment":" Example:\n\n    Head.metaProperty \"fb:app_id\" (Head.raw \"123456789\")\n\nResults in `<meta property=\"fb:app_id\" content=\"123456789\" />`\n\n","type":"String.String -> Head.AttributeValue -> Head.Tag"},{"name":"raw","comment":" Create a raw `AttributeValue` (as opposed to some kind of absolute URL).\n","type":"String.String -> Head.AttributeValue"},{"name":"rootLanguage","comment":" Set the language for a page.\n\n<https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang>\n\n    import Head\n    import LanguageTag\n    import LanguageTag.Language\n\n    LanguageTag.Language.de -- sets the page's language to German\n        |> LanguageTag.build LanguageTag.emptySubtags\n        |> Head.rootLanguage\n\nThis results pre-rendered HTML with a global lang tag set.\n\n```html\n<html lang=\"no\">\n...\n</html>\n```\n\n","type":"LanguageTag.LanguageTag -> Head.Tag"},{"name":"rssLink","comment":" Add a link to the site's RSS feed.\n\nExample:\n\n    rssLink \"/feed.xml\"\n\n```html\n<link rel=\"alternate\" type=\"application/rss+xml\" href=\"/rss.xml\">\n```\n\n","type":"String.String -> Head.Tag"},{"name":"sitemapLink","comment":" Add a link to the site's RSS feed.\n\nExample:\n\n    sitemapLink \"/feed.xml\"\n\n```html\n<link rel=\"sitemap\" type=\"application/xml\" href=\"/sitemap.xml\">\n```\n\n","type":"String.String -> Head.Tag"},{"name":"structuredData","comment":" You can learn more about structured data in [Google's intro to structured data](https://developers.google.com/search/docs/guides/intro-structured-data).\n\nWhen you add a `structuredData` item to one of your pages in `elm-pages`, it will add `json-ld` data to your document that looks like this:\n\n```html\n<script type=\"application/ld+json\">\n{\n   \"@context\":\"http://schema.org/\",\n   \"@type\":\"Article\",\n   \"headline\":\"Extensible Markdown Parsing in Pure Elm\",\n   \"description\":\"Introducing a new parser that extends your palette with no additional syntax\",\n   \"image\":\"https://elm-pages.com/images/article-covers/extensible-markdown-parsing.jpg\",\n   \"author\":{\n      \"@type\":\"Person\",\n      \"name\":\"Dillon Kearns\"\n   },\n   \"publisher\":{\n      \"@type\":\"Person\",\n      \"name\":\"Dillon Kearns\"\n   },\n   \"url\":\"https://elm-pages.com/blog/extensible-markdown-parsing-in-elm\",\n   \"datePublished\":\"2019-10-08\",\n   \"mainEntityOfPage\":{\n      \"@type\":\"SoftwareSourceCode\",\n      \"codeRepository\":\"https://github.com/dillonkearns/elm-pages\",\n      \"description\":\"A statically typed site generator for Elm.\",\n      \"author\":\"Dillon Kearns\",\n      \"programmingLanguage\":{\n         \"@type\":\"ComputerLanguage\",\n         \"url\":\"http://elm-lang.org/\",\n         \"name\":\"Elm\",\n         \"image\":\"http://elm-lang.org/\",\n         \"identifier\":\"http://elm-lang.org/\"\n      }\n   }\n}\n</script>\n```\n\nTo get that data, you would write this in your `elm-pages` head tags:\n\n    import Json.Encode as Encode\n\n    {-| <https://schema.org/Article>\n    -}\n    encodeArticle :\n        { title : String\n        , description : String\n        , author : StructuredDataHelper { authorMemberOf | personOrOrganization : () } authorPossibleFields\n        , publisher : StructuredDataHelper { publisherMemberOf | personOrOrganization : () } publisherPossibleFields\n        , url : String\n        , imageUrl : String\n        , datePublished : String\n        , mainEntityOfPage : Encode.Value\n        }\n        -> Head.Tag\n    encodeArticle info =\n        Encode.object\n            [ ( \"@context\", Encode.string \"http://schema.org/\" )\n            , ( \"@type\", Encode.string \"Article\" )\n            , ( \"headline\", Encode.string info.title )\n            , ( \"description\", Encode.string info.description )\n            , ( \"image\", Encode.string info.imageUrl )\n            , ( \"author\", encode info.author )\n            , ( \"publisher\", encode info.publisher )\n            , ( \"url\", Encode.string info.url )\n            , ( \"datePublished\", Encode.string info.datePublished )\n            , ( \"mainEntityOfPage\", info.mainEntityOfPage )\n            ]\n            |> Head.structuredData\n\nTake a look at this [Google Search Gallery](https://developers.google.com/search/docs/guides/search-gallery)\nto see some examples of how structured data can be used by search engines to give rich search results. It can help boost\nyour rankings, get better engagement for your content, and also make your content more accessible. For example,\nvoice assistant devices can make use of structured data. If you're hosting a conference and want to make the event\ndate and location easy for attendees to find, this can make that information more accessible.\n\nFor the current version of API, you'll need to make sure that the format is correct and contains the required and recommended\nstructure.\n\nCheck out <https://schema.org> for a comprehensive listing of possible data types and fields. And take a look at\nGoogle's [Structured Data Testing Tool](https://search.google.com/structured-data/testing-tool)\ntoo make sure that your structured data is valid and includes the recommended values.\n\nIn the future, `elm-pages` will likely support a typed API, but schema.org is a massive spec, and changes frequently.\nAnd there are multiple sources of information on the possible and recommended structure. So it will take some time\nfor the right API design to evolve. In the meantime, this allows you to make use of this for SEO purposes.\n\n","type":"Json.Encode.Value -> Head.Tag"},{"name":"toJson","comment":" Feel free to use this, but in 99% of cases you won't need it. The generated\ncode will run this for you to generate your `manifest.json` file automatically!\n","type":"String.String -> String.String -> Head.Tag -> Json.Encode.Value"},{"name":"urlAttribute","comment":" Create an `AttributeValue` from an `ImagePath`.\n","type":"Pages.Url.Url -> Head.AttributeValue"}],"binops":[]},{"name":"Head.Seo","comment":" <https://ogp.me/#>\n<https://developers.facebook.com/docs/sharing/opengraph>\n\nThis module encapsulates some of the best practices for SEO for your site.\n\n`elm-pages` will pre-render each of the static pages (in your `content` directory) so that\nweb crawlers can efficiently and accurately process it. The functions in this module are for use\nwith the `head` function that you pass to your Pages config (`Pages.application`).\n\n    import Date\n    import Head\n    import Head.Seo as Seo\n\n\n    -- justinmimbs/date package\n    type alias ArticleMetadata =\n        { title : String\n        , description : String\n        , published : Date\n        , author : Data.Author.Author\n        }\n\n    head : ArticleMetadata -> List Head.Tag\n    head articleMetadata =\n        Seo.summaryLarge\n            { canonicalUrlOverride = Nothing\n            , siteName = \"elm-pages\"\n            , image =\n                { url = Pages.images.icon\n                , alt = articleMetadata.description\n                , dimensions = Nothing\n                , mimeType = Nothing\n                }\n            , description = articleMetadata.description\n            , locale = Nothing\n            , title = articleMetadata.title\n            }\n            |> Seo.article\n                { tags = []\n                , section = Nothing\n                , publishedTime = Just (Date.toIsoString articleMetadata.published)\n                , modifiedTime = Nothing\n                , expirationTime = Nothing\n                }\n\n@docs Common, Image, article, audioPlayer, book, profile, song, summary, summaryLarge, videoPlayer, website\n\n","unions":[],"aliases":[{"name":"Common","comment":" These fields apply to any type in the og object types\nSee <https://ogp.me/#metadata> and <https://ogp.me/#optional>\n\nSkipping this for now, if there's a use case I can add it in:\n\n  - og:determiner - The word that appears before this object's title in a sentence. An enum of (a, an, the, \"\", auto). If auto is chosen, the consumer of your data should chose between \"a\" or \"an\". Default is \"\" (blank).\n\n","args":[],"type":"{ title : String.String, image : Head.Seo.Image, canonicalUrlOverride : Maybe.Maybe String.String, description : String.String, siteName : String.String, audio : Maybe.Maybe Head.Seo.Audio, video : Maybe.Maybe Head.Seo.Video, locale : Maybe.Maybe Head.Seo.Locale, alternateLocales : List.List Head.Seo.Locale, twitterCard : Head.Twitter.TwitterCard }"},{"name":"Image","comment":" See <https://ogp.me/#structured>\n","args":[],"type":"{ url : Pages.Url.Url, alt : String.String, dimensions : Maybe.Maybe { width : Basics.Int, height : Basics.Int }, mimeType : Maybe.Maybe Head.Seo.MimeType }"}],"values":[{"name":"article","comment":" See <https://ogp.me/#type_article>\n","type":"{ tags : List.List String.String, section : Maybe.Maybe String.String, publishedTime : Maybe.Maybe Head.Seo.Iso8601DateTime, modifiedTime : Maybe.Maybe Head.Seo.Iso8601DateTime, expirationTime : Maybe.Maybe Head.Seo.Iso8601DateTime } -> Head.Seo.Common -> List.List Head.Tag"},{"name":"audioPlayer","comment":" Will be displayed as a Player card in twitter\nSee: <https://developer.twitter.com/en/docs/tweets/optimize-with-cards/overview/player-card>\n\nOpenGraph audio will also be included.\nThe options will also be used to build up the appropriate OpenGraph `<meta>` tags.\n\n","type":"{ canonicalUrlOverride : Maybe.Maybe String.String, siteName : String.String, image : Head.Seo.Image, description : String.String, title : String.String, audio : Head.Seo.Audio, locale : Maybe.Maybe Head.Seo.Locale } -> Head.Seo.Common"},{"name":"book","comment":" See <https://ogp.me/#type_book>\n","type":"Head.Seo.Common -> { tags : List.List String.String, isbn : Maybe.Maybe String.String, releaseDate : Maybe.Maybe Head.Seo.Iso8601DateTime } -> List.List Head.Tag"},{"name":"profile","comment":" See <https://ogp.me/#type_profile>\n","type":"{ firstName : String.String, lastName : String.String, username : Maybe.Maybe String.String } -> Head.Seo.Common -> List.List Head.Tag"},{"name":"song","comment":" See <https://ogp.me/#type_music.song>\n","type":"Head.Seo.Common -> { duration : Maybe.Maybe Basics.Int, album : Maybe.Maybe Basics.Int, disc : Maybe.Maybe Basics.Int, track : Maybe.Maybe Basics.Int } -> List.List Head.Tag"},{"name":"summary","comment":" Will be displayed as a large card in twitter\nSee: <https://developer.twitter.com/en/docs/tweets/optimize-with-cards/overview/summary>\n\nThe options will also be used to build up the appropriate OpenGraph `<meta>` tags.\n\nNote: You cannot include audio or video tags with summaries.\nIf you want one of those, use `audioPlayer` or `videoPlayer`\n\n","type":"{ canonicalUrlOverride : Maybe.Maybe String.String, siteName : String.String, image : Head.Seo.Image, description : String.String, title : String.String, locale : Maybe.Maybe Head.Seo.Locale } -> Head.Seo.Common"},{"name":"summaryLarge","comment":" Will be displayed as a large card in twitter\nSee: <https://developer.twitter.com/en/docs/tweets/optimize-with-cards/overview/summary-card-with-large-image>\n\nThe options will also be used to build up the appropriate OpenGraph `<meta>` tags.\n\nNote: You cannot include audio or video tags with summaries.\nIf you want one of those, use `audioPlayer` or `videoPlayer`\n\n","type":"{ canonicalUrlOverride : Maybe.Maybe String.String, siteName : String.String, image : Head.Seo.Image, description : String.String, title : String.String, locale : Maybe.Maybe Head.Seo.Locale } -> Head.Seo.Common"},{"name":"videoPlayer","comment":" Will be displayed as a Player card in twitter\nSee: <https://developer.twitter.com/en/docs/tweets/optimize-with-cards/overview/player-card>\n\nOpenGraph video will also be included.\nThe options will also be used to build up the appropriate OpenGraph `<meta>` tags.\n\n","type":"{ canonicalUrlOverride : Maybe.Maybe String.String, siteName : String.String, image : Head.Seo.Image, description : String.String, title : String.String, video : Head.Seo.Video, locale : Maybe.Maybe Head.Seo.Locale } -> Head.Seo.Common"},{"name":"website","comment":" <https://ogp.me/#type_website>\n","type":"Head.Seo.Common -> List.List Head.Tag"}],"binops":[]},{"name":"OptimizedDecoder","comment":" This module allows you to build decoders that `elm-pages` can optimize for you in your `StaticHttp` requests.\nIt does this by stripping of unused fields during the CLI build step. When it runs in production, it will\njust run a plain `elm/json` decoder, so you're fetching and decoding the stripped-down data, but without any\nperformance penalty.\n\nFor convenience, this library also includes a `Json.Decode.Exploration.Pipeline`\nmodule which is largely a copy of [`NoRedInk/elm-decode-pipeline`][edp].\n\n[edp]: http://package.elm-lang.org/packages/NoRedInk/elm-decode-pipeline/latest\n\n\n## Dealing with warnings and errors\n\n@docs Error, errorToString\n\n\n# Primitives\n\n@docs Decoder, string, bool, int, float, Value\n\n\n# Data Structures\n\n@docs nullable, list, array, dict, keyValuePairs\n\n\n# Object Primitives\n\n@docs field, at, index, optionalField\n\n\n# Inconsistent Structure\n\n@docs maybe, oneOf\n\n\n# Fancy Decoding\n\n@docs lazy, value, null, succeed, fail, andThen\n\n\n# Mapping\n\n**Note:** If you run out of map functions, take a look at [the pipeline module][pipe]\nwhich makes it easier to handle large objects.\n\n[pipe]: http://package.elm-lang.org/packages/zwilias/json-decode-exploration/latest/Json-Decode-Exploration-Pipeline\n\n@docs map, map2, map3, map4, map5, map6, map7, map8, andMap\n\n@docs fromResult\n\n\n# Directly Running Decoders\n\nUsually you'll be passing your decoders to\n\n@docs decodeString, decodeValue, decoder\n\n","unions":[],"aliases":[{"name":"Decoder","comment":" A decoder that will be optimized in your production bundle.\n","args":["a"],"type":"Internal.OptimizedDecoder.OptimizedDecoder a"},{"name":"Error","comment":" A simple type alias for `Json.Decode.Error`.\n","args":[],"type":"Json.Decode.Error"},{"name":"Value","comment":" A simple type alias for `Json.Decode.Value`.\n","args":[],"type":"Json.Decode.Value"}],"values":[{"name":"andMap","comment":" Decode an argument and provide it to a function in a decoder.\n\n    decoder : Decoder String\n    decoder =\n        succeed (String.repeat)\n            |> andMap (field \"count\" int)\n            |> andMap (field \"val\" string)\n\n\n    \"\"\" { \"val\": \"hi\", \"count\": 3 } \"\"\"\n        |> decodeString decoder\n    --> Success \"hihihi\"\n\n","type":"OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder (a -> b) -> OptimizedDecoder.Decoder b"},{"name":"andThen","comment":" Chain decoders where one decoder depends on the value of another decoder.\n","type":"(a -> OptimizedDecoder.Decoder b) -> OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder b"},{"name":"array","comment":" _Convenience function._ Decode a JSON array into an Elm `Array`.\n\n    import Array\n\n    \"\"\" [ 1, 2, 3 ] \"\"\"\n        |> decodeString (array int)\n    --> Success <| Array.fromList [ 1, 2, 3 ]\n\n","type":"OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder (Array.Array a)"},{"name":"at","comment":" Decodes a value at a certain path, using a provided decoder. Essentially,\nwriting `at [ \"a\", \"b\", \"c\" ]  string` is sugar over writing\n`field \"a\" (field \"b\" (field \"c\" string))`}.\n\n    \"\"\" { \"a\": { \"b\": { \"c\": \"hi there\" } } } \"\"\"\n        |> decodeString (at [ \"a\", \"b\", \"c\" ] string)\n    --> Success \"hi there\"\n\n","type":"List.List String.String -> OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder a"},{"name":"bool","comment":" Decode a boolean value.\n\n    \"\"\" [ true, false ] \"\"\"\n        |> decodeString (list bool)\n    --> Success [ True, False ]\n\n","type":"OptimizedDecoder.Decoder Basics.Bool"},{"name":"decodeString","comment":" A simple wrapper for `Json.Decode.errorToString`.\n\nThis will directly call the raw `elm/json` decoder that is stored under the hood.\n\n","type":"OptimizedDecoder.Decoder a -> String.String -> Result.Result OptimizedDecoder.Error a"},{"name":"decodeValue","comment":" A simple wrapper for `Json.Decode.errorToString`.\n\nThis will directly call the raw `elm/json` decoder that is stored under the hood.\n\n","type":"OptimizedDecoder.Decoder a -> OptimizedDecoder.Value -> Result.Result OptimizedDecoder.Error a"},{"name":"decoder","comment":" Usually you'll want to directly pass your `OptimizedDecoder` to `StaticHttp` or other `elm-pages` APIs.\nBut if you want to re-use your decoder somewhere else, it may be useful to turn it into a plain `elm/json` decoder.\n","type":"OptimizedDecoder.Decoder a -> Json.Decode.Decoder a"},{"name":"dict","comment":" _Convenience function._ Decode a JSON object into an Elm `Dict String`.\n\n    import Dict\n\n\n    \"\"\" { \"foo\": \"bar\", \"bar\": \"hi there\" } \"\"\"\n        |> decodeString (dict string)\n    --> Success <| Dict.fromList\n    -->   [ ( \"bar\", \"hi there\" )\n    -->   , ( \"foo\", \"bar\" )\n    -->   ]\n\n","type":"OptimizedDecoder.Decoder v -> OptimizedDecoder.Decoder (Dict.Dict String.String v)"},{"name":"errorToString","comment":" A simple wrapper for `Json.Decode.errorToString`.\n","type":"Json.Decode.Error -> String.String"},{"name":"fail","comment":" Ignore the json and fail with a provided message.\n\n    import List.Nonempty exposing (Nonempty(..))\n    import Json.Decode.Exploration.Located exposing (Located(..))\n    import Json.Encode as Encode\n\n    \"\"\" \"hello\" \"\"\"\n        |> decodeString (fail \"failure\")\n    --> Errors (Nonempty (Here <| Failure \"failure\" (Just <| Encode.string \"hello\")) [])\n\n","type":"String.String -> OptimizedDecoder.Decoder a"},{"name":"field","comment":" Decode the content of a field using a provided decoder.\n\n    import List.Nonempty as Nonempty\n    import Json.Decode.Exploration.Located exposing (Located(..))\n    import Json.Encode as Encode\n\n    \"\"\" { \"foo\": \"bar\" } \"\"\"\n        |> decodeString (field \"foo\" string)\n    --> Success \"bar\"\n\n\n    \"\"\" [ { \"foo\": \"bar\" }, { \"foo\": \"baz\", \"hello\": \"world\" } ] \"\"\"\n        |> decodeString (list (field \"foo\" string))\n    --> WithWarnings expectedWarnings [ \"bar\", \"baz\" ]\n\n\n    expectedWarnings : Warnings\n    expectedWarnings =\n        UnusedField \"hello\"\n            |> Here\n            |> Nonempty.fromElement\n            |> AtIndex 1\n            |> Nonempty.fromElement\n\n","type":"String.String -> OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder a"},{"name":"float","comment":" Decode a number into a `Float`.\n\n    import List.Nonempty exposing (Nonempty(..))\n    import Json.Decode.Exploration.Located exposing (Located(..))\n    import Json.Encode as Encode\n\n\n    \"\"\" 12.34 \"\"\"\n        |> decodeString float\n    --> Success 12.34\n\n\n    \"\"\" 12 \"\"\"\n        |> decodeString float\n    --> Success 12\n\n\n    \"\"\" null \"\"\"\n        |> decodeString float\n    --> Errors (Nonempty (Here <| Expected TNumber Encode.null) [])\n\n","type":"OptimizedDecoder.Decoder Basics.Float"},{"name":"fromResult","comment":" Turn a Result into a Decoder (uses succeed and fail under the hood). This is often\nhelpful for chaining with `andThen`.\n","type":"Result.Result String.String value -> OptimizedDecoder.Decoder value"},{"name":"index","comment":" Decode a specific index using a specified `Decoder`.\n\n    import List.Nonempty exposing (Nonempty(..))\n    import Json.Decode.Exploration.Located exposing (Located(..))\n    import Json.Encode as Encode\n\n\n    \"\"\" [ \"hello\", 123 ] \"\"\"\n        |> decodeString (map2 Tuple.pair (index 0 string) (index 1 int))\n    --> Success ( \"hello\", 123 )\n\n\n    \"\"\" [ \"hello\", \"there\" ] \"\"\"\n        |> decodeString (index 1 string)\n    --> WithWarnings (Nonempty (AtIndex 0 (Nonempty (Here (UnusedValue (Encode.string \"hello\"))) [])) [])\n    -->   \"there\"\n\n","type":"Basics.Int -> OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder a"},{"name":"int","comment":" Decode a number into an `Int`.\n\n    import List.Nonempty exposing (Nonempty(..))\n    import Json.Decode.Exploration.Located exposing (Located(..))\n    import Json.Encode as Encode\n\n\n    \"\"\" 123 \"\"\"\n        |> decodeString int\n    --> Success 123\n\n\n    \"\"\" 0.1 \"\"\"\n        |> decodeString int\n    --> Errors <|\n    -->   Nonempty\n    -->     (Here <| Expected TInt (Encode.float 0.1))\n    -->     []\n\n","type":"OptimizedDecoder.Decoder Basics.Int"},{"name":"keyValuePairs","comment":" Decode a JSON object into a list of key-value pairs. The decoder you provide\nwill be used to decode the values.\n\n    \"\"\" { \"foo\": \"bar\", \"hello\": \"world\" } \"\"\"\n        |> decodeString (keyValuePairs string)\n    --> Success [ ( \"foo\", \"bar\" ), ( \"hello\", \"world\" ) ]\n\n","type":"OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder (List.List ( String.String, a ))"},{"name":"lazy","comment":" Required when using (mutually) recursive decoders.\n","type":"(() -> OptimizedDecoder.Decoder a) -> OptimizedDecoder.Decoder a"},{"name":"list","comment":" Decode a list of values, decoding each entry with the provided decoder.\n\n    import List.Nonempty exposing (Nonempty(..))\n    import Json.Decode.Exploration.Located exposing (Located(..))\n    import Json.Encode as Encode\n\n\n    \"\"\" [ \"foo\", \"bar\" ] \"\"\"\n        |> decodeString (list string)\n    --> Success [ \"foo\", \"bar\" ]\n\n\n    \"\"\" [ \"foo\", null ] \"\"\"\n        |> decodeString (list string)\n    --> Errors <|\n    -->   Nonempty\n    -->     (AtIndex 1 <|\n    -->       Nonempty (Here <| Expected TString Encode.null) []\n    -->     )\n    -->     []\n\n","type":"OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder (List.List a)"},{"name":"map","comment":" Useful for transforming decoders.\n\n    \"\"\" \"foo\" \"\"\"\n        |> decodeString (map String.toUpper string)\n    --> Success \"FOO\"\n\n","type":"(a -> b) -> OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder b"},{"name":"map2","comment":" Combine 2 decoders.\n","type":"(a -> b -> c) -> OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder b -> OptimizedDecoder.Decoder c"},{"name":"map3","comment":" Combine 3 decoders.\n","type":"(a -> b -> c -> d) -> OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder b -> OptimizedDecoder.Decoder c -> OptimizedDecoder.Decoder d"},{"name":"map4","comment":" Combine 4 decoders.\n","type":"(a -> b -> c -> d -> e) -> OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder b -> OptimizedDecoder.Decoder c -> OptimizedDecoder.Decoder d -> OptimizedDecoder.Decoder e"},{"name":"map5","comment":" Combine 5 decoders.\n","type":"(a -> b -> c -> d -> e -> f) -> OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder b -> OptimizedDecoder.Decoder c -> OptimizedDecoder.Decoder d -> OptimizedDecoder.Decoder e -> OptimizedDecoder.Decoder f"},{"name":"map6","comment":" Combine 6 decoders.\n","type":"(a -> b -> c -> d -> e -> f -> g) -> OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder b -> OptimizedDecoder.Decoder c -> OptimizedDecoder.Decoder d -> OptimizedDecoder.Decoder e -> OptimizedDecoder.Decoder f -> OptimizedDecoder.Decoder g"},{"name":"map7","comment":" Combine 7 decoders.\n","type":"(a -> b -> c -> d -> e -> f -> g -> h) -> OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder b -> OptimizedDecoder.Decoder c -> OptimizedDecoder.Decoder d -> OptimizedDecoder.Decoder e -> OptimizedDecoder.Decoder f -> OptimizedDecoder.Decoder g -> OptimizedDecoder.Decoder h"},{"name":"map8","comment":" Combine 8 decoders.\n","type":"(a -> b -> c -> d -> e -> f -> g -> h -> i) -> OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder b -> OptimizedDecoder.Decoder c -> OptimizedDecoder.Decoder d -> OptimizedDecoder.Decoder e -> OptimizedDecoder.Decoder f -> OptimizedDecoder.Decoder g -> OptimizedDecoder.Decoder h -> OptimizedDecoder.Decoder i"},{"name":"maybe","comment":" Decodes successfully and wraps with a `Just`, handling failure by succeeding\nwith `Nothing`.\n\n    import List.Nonempty as Nonempty\n    import Json.Decode.Exploration.Located exposing (Located(..))\n    import Json.Encode as Encode\n\n\n    \"\"\" [ \"foo\", 12 ] \"\"\"\n        |> decodeString (list <| maybe string)\n    --> WithWarnings expectedWarnings [ Just \"foo\", Nothing ]\n\n\n    expectedWarnings : Warnings\n    expectedWarnings =\n        UnusedValue (Encode.int 12)\n            |> Here\n            |> Nonempty.fromElement\n            |> AtIndex 1\n            |> Nonempty.fromElement\n\n","type":"OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder (Maybe.Maybe a)"},{"name":"null","comment":" Decode a `null` and succeed with some value.\n\n    \"\"\" null \"\"\"\n        |> decodeString (null \"it was null\")\n    --> Success \"it was null\"\n\nNote that `undefined` and `null` are not the same thing. This cannot be used to\nverify that a field is _missing_, only that it is explicitly set to `null`.\n\n    \"\"\" { \"foo\": null } \"\"\"\n        |> decodeString (field \"foo\" (null ()))\n    --> Success ()\n\n\n    import List.Nonempty exposing (Nonempty(..))\n    import Json.Decode.Exploration.Located exposing (Located(..))\n    import Json.Encode as Encode\n\n\n    \"\"\" { } \"\"\"\n        |> decodeString (field \"foo\" (null ()))\n    --> Errors <|\n    -->   Nonempty\n    -->     (Here <| Expected (TObjectField \"foo\") (Encode.object []))\n    -->     []\n\n","type":"a -> OptimizedDecoder.Decoder a"},{"name":"nullable","comment":" Decodes successfully and wraps with a `Just`. If the values is `null`\nsucceeds with `Nothing`.\n\n    \"\"\" [ { \"foo\": \"bar\" }, { \"foo\": null } ] \"\"\"\n        |> decodeString (list <| field \"foo\" <| nullable string)\n    --> Success [ Just \"bar\", Nothing ]\n\n","type":"OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder (Maybe.Maybe a)"},{"name":"oneOf","comment":" Tries a bunch of decoders. The first one to not fail will be the one used.\n\nIf all fail, the errors are collected into a `BadOneOf`.\n\n    import List.Nonempty as Nonempty\n    import Json.Decode.Exploration.Located exposing (Located(..))\n    import Json.Encode as Encode\n\n    \"\"\" [ 12, \"whatever\" ] \"\"\"\n        |> decodeString (list <| oneOf [ map String.fromInt int, string ])\n    --> Success [ \"12\", \"whatever\" ]\n\n\n    \"\"\" null \"\"\"\n        |> decodeString (oneOf [ string, map String.fromInt int ])\n    --> Errors <| Nonempty.fromElement <| Here <| BadOneOf\n    -->   [ Nonempty.fromElement <| Here <| Expected TString Encode.null\n    -->   , Nonempty.fromElement <| Here <| Expected TInt Encode.null\n    -->   ]\n\n","type":"List.List (OptimizedDecoder.Decoder a) -> OptimizedDecoder.Decoder a"},{"name":"optionalField","comment":" If a field is missing, succeed with `Nothing`. If it is present, decode it\nas normal and wrap successes in a `Just`.\n\nWhen decoding with\n[`maybe`](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#maybe),\nif a field is present but malformed, you get a success and Nothing.\n`optionalField` gives you a failed decoding in that case, so you know\nyou received malformed data.\n\nExamples:\n\n    import Json.Decode exposing (..)\n    import Json.Encode\n\nLet's define a `stuffDecoder` that extracts the `\"stuff\"` field, if it exists.\n\n    stuffDecoder : Decoder (Maybe String)\n    stuffDecoder =\n        optionalField \"stuff\" string\n\nIf the \"stuff\" field is missing, decode to Nothing.\n\n    \"\"\" { } \"\"\"\n        |> decodeString stuffDecoder\n    --> Ok Nothing\n\nIf the \"stuff\" field is present but not a String, fail decoding.\n\n    expectedError : Error\n    expectedError =\n        Failure \"Expecting a STRING\" (Json.Encode.list identity [])\n          |> Field \"stuff\"\n\n    \"\"\" { \"stuff\": [] } \"\"\"\n        |> decodeString stuffDecoder\n    --> Err expectedError\n\nIf the \"stuff\" field is present and valid, decode to Just String.\n\n    \"\"\" { \"stuff\": \"yay!\" } \"\"\"\n        |> decodeString stuffDecoder\n    --> Ok <| Just \"yay!\"\n\nDefinition from the json-extra package: <https://github.com/elm-community/json-extra>.\n\n","type":"String.String -> OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder (Maybe.Maybe a)"},{"name":"string","comment":" Decode a string.\n\n    import List.Nonempty exposing (Nonempty(..))\n    import Json.Decode.Exploration.Located exposing (Located(..))\n    import Json.Encode as Encode\n\n\n    \"\"\" \"hello world\" \"\"\"\n        |> decodeString string\n    --> Success \"hello world\"\n\n\n    \"\"\" 123 \"\"\"\n        |> decodeString string\n    --> Errors (Nonempty (Here <| Expected TString (Encode.int 123)) [])\n\n","type":"OptimizedDecoder.Decoder String.String"},{"name":"succeed","comment":" A decoder that will ignore the actual JSON and succeed with the provided\nvalue. Note that this may still fail when dealing with an invalid JSON string.\n\nIf a value in the JSON ends up being ignored because of this, this will cause a\nwarning.\n\n    import List.Nonempty exposing (Nonempty(..))\n    import Json.Decode.Exploration.Located exposing (Located(..))\n    import Json.Encode as Encode\n\n\n    \"\"\" null \"\"\"\n        |> decodeString (value |> andThen (\\_ -> succeed \"hello world\"))\n    --> Success \"hello world\"\n\n\n    \"\"\" null \"\"\"\n        |> decodeString (succeed \"hello world\")\n    --> WithWarnings\n    -->     (Nonempty (Here <| UnusedValue Encode.null) [])\n    -->     \"hello world\"\n\n\n    \"\"\" foo \"\"\"\n        |> decodeString (succeed \"hello world\")\n    --> BadJson\n\n","type":"a -> OptimizedDecoder.Decoder a"},{"name":"value","comment":" Extract a piece without actually decoding it.\n\nIf a structure is decoded as a `value`, everything _in_ the structure will be\nconsidered as having been used and will not appear in `UnusedValue` warnings.\n\n    import Json.Encode as Encode\n\n\n    \"\"\" [ 123, \"world\" ] \"\"\"\n        |> decodeString value\n    --> Success (Encode.list identity [ Encode.int 123, Encode.string \"world\" ])\n\n","type":"OptimizedDecoder.Decoder OptimizedDecoder.Value"}],"binops":[]},{"name":"OptimizedDecoder.Pipeline","comment":"\n\n\n# Json.Decode.Pipeline\n\nUse the `(|>)` operator to build JSON decoders.\n\n\n## Decoding fields\n\n@docs required, requiredAt, optional, optionalAt, hardcoded, custom\n\n\n## Beginning and ending pipelines\n\n@docs decode, resolve\n\n\n### Verified docs\n\nThe examples all expect imports set up like this:\n\n    import Json.Decode.Exploration exposing (..)\n    import Json.Decode.Exploration.Pipeline exposing (..)\n    import Json.Decode.Exploration.Located exposing (Located(..))\n    import Json.Encode as Encode\n    import List.Nonempty as Nonempty\n\nFor automated verification of these examples, this import is also required.\nPlease ignore it.\n\n    import DocVerificationHelpers exposing (User)\n\n","unions":[],"aliases":[],"values":[{"name":"custom","comment":" Run the given decoder and feed its result into the pipeline at this point.\n\nConsider this example.\n\n    import Json.Decode.Exploration exposing (..)\n\n\n    type alias User =\n        { id : Int\n        , name : String\n        , email : String\n        }\n\n    userDecoder : Decoder User\n    userDecoder =\n        decode User\n            |> required \"id\" int\n            |> custom (at [ \"profile\", \"name\" ] string)\n            |> required \"email\" string\n\n    \"\"\"\n    {\n        \"id\": 123,\n        \"email\": \"sam@example.com\",\n        \"profile\": {\"name\": \"Sam\"}\n    }\n    \"\"\"\n        |> decodeString userDecoder\n    --> Success { id = 123, name = \"Sam\", email = \"sam@example.com\" }\n\n","type":"OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder (a -> b) -> OptimizedDecoder.Decoder b"},{"name":"decode","comment":" Begin a decoding pipeline. This is a synonym for [Json.Decode.succeed](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#succeed),\nintended to make things read more clearly.\n\n    type alias User =\n        { id : Int\n        , email : String\n        , name : String\n        }\n\n    userDecoder : Decoder User\n    userDecoder =\n        decode User\n            |> required \"id\" int\n            |> required \"email\" string\n            |> optional \"name\" string \"\"\n\n","type":"a -> OptimizedDecoder.Decoder a"},{"name":"hardcoded","comment":" Rather than decoding anything, use a fixed value for the next step in the\npipeline. `harcoded` does not look at the JSON at all.\n\n    import Json.Decode.Exploration exposing (..)\n\n\n    type alias User =\n        { id : Int\n        , name : String\n        , email : String\n        }\n\n    userDecoder : Decoder User\n    userDecoder =\n        decode User\n            |> required \"id\" int\n            |> hardcoded \"Alex\"\n            |> required \"email\" string\n\n    \"\"\" { \"id\": 123, \"email\": \"sam@example.com\" } \"\"\"\n        |> decodeString userDecoder\n    --> Success { id = 123, name = \"Alex\", email = \"sam@example.com\" }\n\n","type":"a -> OptimizedDecoder.Decoder (a -> b) -> OptimizedDecoder.Decoder b"},{"name":"optional","comment":" Decode a field that may be missing or have a null value. If the field is\nmissing, then it decodes as the `fallback` value. If the field is present,\nthen `valDecoder` is used to decode its value. If `valDecoder` fails on a\n`null` value, then the `fallback` is used as if the field were missing\nentirely.\n\n    import Json.Decode.Exploration exposing (..)\n\n    type alias User =\n        { id : Int\n        , name : String\n        , email : String\n        }\n\n    userDecoder : Decoder User\n    userDecoder =\n        decode User\n            |> required \"id\" int\n            |> optional \"name\" string \"blah\"\n            |> required \"email\" string\n\n    \"\"\" { \"id\": 123, \"email\": \"sam@example.com\" } \"\"\"\n        |> decodeString userDecoder\n    --> Success { id = 123, name = \"blah\", email = \"sam@example.com\" }\n\nBecause `valDecoder` is given an opportunity to decode `null` values before\nresorting to the `fallback`, you can distinguish between missing and `null`\nvalues if you need to:\n\n    userDecoder2 =\n        decode User\n            |> required \"id\" int\n            |> optional \"name\" (oneOf [ string, null \"NULL\" ]) \"MISSING\"\n            |> required \"email\" string\n\nNote also that this behaves _slightly_ different than the stock pipeline\npackage.\n\nIn the stock pipeline package, running the following decoder with an array as\nthe input would _succeed_.\n\n    fooDecoder =\n        decode identity\n            |> optional \"foo\" (maybe string) Nothing\n\nIn this package, such a decoder will error out instead, saying that it expected\nthe input to be an object. The _key_ `\"foo\"` is optional, but it really does\nhave to be an object before we even consider trying your decoder or returning\nthe fallback.\n\n","type":"String.String -> OptimizedDecoder.Decoder a -> a -> OptimizedDecoder.Decoder (a -> b) -> OptimizedDecoder.Decoder b"},{"name":"optionalAt","comment":" Decode an optional nested field.\n","type":"List.List String.String -> OptimizedDecoder.Decoder a -> a -> OptimizedDecoder.Decoder (a -> b) -> OptimizedDecoder.Decoder b"},{"name":"required","comment":" Decode a required field.\n\n    import Json.Decode.Exploration exposing (..)\n\n    type alias User =\n        { id : Int\n        , name : String\n        , email : String\n        }\n\n    userDecoder : Decoder User\n    userDecoder =\n        decode User\n            |> required \"id\" int\n            |> required \"name\" string\n            |> required \"email\" string\n\n    \"\"\" {\"id\": 123, \"email\": \"sam@example.com\", \"name\": \"Sam\"} \"\"\"\n        |> decodeString userDecoder\n    --> Success { id = 123, name = \"Sam\", email = \"sam@example.com\" }\n\n","type":"String.String -> OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder (a -> b) -> OptimizedDecoder.Decoder b"},{"name":"requiredAt","comment":" Decode a required nested field.\n\n    import Json.Decode.Exploration exposing (..)\n\n    type alias User =\n        { id : Int\n        , name : String\n        , email : String\n        }\n\n    userDecoder : Decoder User\n    userDecoder =\n        decode User\n            |> required \"id\" int\n            |> requiredAt [ \"profile\", \"name\" ] string\n            |> required \"email\" string\n\n    \"\"\"\n    {\n        \"id\": 123,\n        \"email\": \"sam@example.com\",\n        \"profile\": { \"name\": \"Sam\" }\n    }\n    \"\"\"\n        |> decodeString userDecoder\n    --> Success { id = 123, name = \"Sam\", email = \"sam@example.com\" }\n\n","type":"List.List String.String -> OptimizedDecoder.Decoder a -> OptimizedDecoder.Decoder (a -> b) -> OptimizedDecoder.Decoder b"},{"name":"resolve","comment":" Convert a `Decoder (Result x a)` into a `Decoder a`. Useful when you want\nto perform some custom processing just before completing the decoding operation.\n\n    import Json.Decode.Exploration exposing (..)\n\n    type alias User =\n        { id : Int\n        , name : String\n        , email : String\n        }\n\n    userDecoder : Decoder User\n    userDecoder =\n        let\n            -- toDecoder gets run *after* all the\n            -- (|> required ...) steps are done.\n            toDecoder : Int -> String -> String -> Int -> Decoder User\n            toDecoder id name email version =\n                if version >= 2 then\n                    succeed (User id name email)\n                else\n                    fail \"This JSON is from a deprecated source. Please upgrade!\"\n        in\n        decode toDecoder\n            |> required \"id\" int\n            |> required \"name\" string\n            |> required \"email\" string\n            |> required \"version\" int\n            -- version is part of toDecoder,\n            -- but it is not a part of User\n            |> resolve\n\n    \"\"\"\n    {\n        \"id\": 123,\n        \"name\": \"Sam\",\n        \"email\": \"sam@example.com\",\n        \"version\": 3\n    }\n    \"\"\"\n        |> decodeString userDecoder\n    --> Success { id = 123, name = \"Sam\", email = \"sam@example.com\" }\n\n","type":"OptimizedDecoder.Decoder (OptimizedDecoder.Decoder a) -> OptimizedDecoder.Decoder a"}],"binops":[]},{"name":"Pages.Flags","comment":"\n\n@docs Flags\n\n","unions":[{"name":"Flags","comment":" elm-pages apps run in two different contexts\n\n1.  In the browser (like a regular Elm app)\n2.  In pre-render mode. For example when you run `elm-pages build`, there is no browser involved, it just runs Elm directly.\n\nYou can pass in Flags and use them in your `Shared.init` function. You can store data in your `Shared.Model` from these flags and then access it across any page.\n\nYou will need to handle the `PreRender` case with no flags value because there is no browser to get flags from. For example, say you wanted to get the\ncurrent user's Browser window size and pass it in as a flag. When that page is pre-rendered, you need to decide on a value to use for the window size\nsince there is no window (the user hasn't requested the page yet, and the page isn't even loaded in a Browser window yet).\n\n","args":[],"cases":[["BrowserFlags",["Json.Decode.Value"]],["PreRenderFlags",[]]]}],"aliases":[],"values":[],"binops":[]},{"name":"Pages.Manifest","comment":" Represents the configuration of a\n[web manifest file](https://developer.mozilla.org/en-US/docs/Web/Manifest).\n\nYou pass your `Pages.Manifest.Config` record into the `Pages.application` function\n(from your generated `Pages.elm` file).\n\n    import Pages.Manifest as Manifest\n    import Pages.Manifest.Category\n\n    manifest : Manifest.Config\n    manifest =\n        Manifest.init\n            { name = static.siteName\n            , description = \"elm-pages - \" ++ tagline\n            , startUrl = Route.Index {} |> Route.toPath\n            , icons =\n                [ icon webp 192\n                , icon webp 512\n                , icon MimeType.Png 192\n                , icon MimeType.Png 512\n                ]\n            }\n            |> Manifest.withShortName \"elm-pages\"\n\n@docs Config, Icon\n\n\n## Builder options\n\n@docs init\n\n@docs withBackgroundColor, withCategories, withDisplayMode, withIarcRatingId, withLang, withOrientation, withShortName, withThemeColor\n\n\n## Config options\n\n@docs DisplayMode, Orientation, IconPurpose\n\n\n## Functions for use by the generated code (`Pages.elm`)\n\n@docs toJson\n\n","unions":[{"name":"DisplayMode","comment":" See <https://developer.mozilla.org/en-US/docs/Web/Manifest/display>\n","args":[],"cases":[["Fullscreen",[]],["Standalone",[]],["MinimalUi",[]],["Browser",[]]]},{"name":"IconPurpose","comment":" <https://w3c.github.io/manifest/#dfn-icon-purposes>\n","args":[],"cases":[["IconPurposeMonochrome",[]],["IconPurposeMaskable",[]],["IconPurposeAny",[]]]},{"name":"Orientation","comment":" <https://developer.mozilla.org/en-US/docs/Web/Manifest/orientation>\n","args":[],"cases":[["Any",[]],["Natural",[]],["Landscape",[]],["LandscapePrimary",[]],["LandscapeSecondary",[]],["Portrait",[]],["PortraitPrimary",[]],["PortraitSecondary",[]]]}],"aliases":[{"name":"Config","comment":" Represents a [web app manifest file](https://developer.mozilla.org/en-US/docs/Web/Manifest)\n(see above for how to use it).\n","args":[],"type":"{ backgroundColor : Maybe.Maybe Color.Color, categories : List.List Pages.Manifest.Category.Category, displayMode : Pages.Manifest.DisplayMode, orientation : Pages.Manifest.Orientation, description : String.String, iarcRatingId : Maybe.Maybe String.String, name : String.String, themeColor : Maybe.Maybe Color.Color, startUrl : Path.Path, shortName : Maybe.Maybe String.String, icons : List.List Pages.Manifest.Icon, lang : LanguageTag.LanguageTag }"},{"name":"Icon","comment":" <https://developer.mozilla.org/en-US/docs/Web/Manifest/icons>\n","args":[],"type":"{ src : Pages.Url.Url, sizes : List.List ( Basics.Int, Basics.Int ), mimeType : Maybe.Maybe MimeType.MimeImage, purposes : List.List Pages.Manifest.IconPurpose }"}],"values":[{"name":"init","comment":" Setup a minimal Manifest.Config. You can then use the `with...` builder functions to set additional options.\n","type":"{ description : String.String, name : String.String, startUrl : Path.Path, icons : List.List Pages.Manifest.Icon } -> Pages.Manifest.Config"},{"name":"toJson","comment":" Feel free to use this, but in 99% of cases you won't need it. The generated\ncode will run this for you to generate your `manifest.json` file automatically!\n","type":"String.String -> Pages.Manifest.Config -> Json.Encode.Value"},{"name":"withBackgroundColor","comment":" Set <https://developer.mozilla.org/en-US/docs/Web/Manifest/background_color>.\n","type":"Color.Color -> Pages.Manifest.Config -> Pages.Manifest.Config"},{"name":"withCategories","comment":" Set <https://developer.mozilla.org/en-US/docs/Web/Manifest/categories>.\n","type":"List.List Pages.Manifest.Category.Category -> Pages.Manifest.Config -> Pages.Manifest.Config"},{"name":"withDisplayMode","comment":" Set <https://developer.mozilla.org/en-US/docs/Web/Manifest/display>.\n","type":"Pages.Manifest.DisplayMode -> Pages.Manifest.Config -> Pages.Manifest.Config"},{"name":"withIarcRatingId","comment":" Set <https://developer.mozilla.org/en-US/docs/Web/Manifest/iarc_rating_id>.\n","type":"String.String -> Pages.Manifest.Config -> Pages.Manifest.Config"},{"name":"withLang","comment":" Set <https://developer.mozilla.org/en-US/docs/Web/Manifest/lang>.\n","type":"LanguageTag.LanguageTag -> Pages.Manifest.Config -> Pages.Manifest.Config"},{"name":"withOrientation","comment":" Set <https://developer.mozilla.org/en-US/docs/Web/Manifest/orientation>.\n","type":"Pages.Manifest.Orientation -> Pages.Manifest.Config -> Pages.Manifest.Config"},{"name":"withShortName","comment":" Set <https://developer.mozilla.org/en-US/docs/Web/Manifest/short_name>.\n","type":"String.String -> Pages.Manifest.Config -> Pages.Manifest.Config"},{"name":"withThemeColor","comment":" Set <https://developer.mozilla.org/en-US/docs/Web/Manifest/theme_color>.\n","type":"Color.Color -> Pages.Manifest.Config -> Pages.Manifest.Config"}],"binops":[]},{"name":"Pages.Manifest.Category","comment":" See <https://github.com/w3c/manifest/wiki/Categories> and\n<https://developer.mozilla.org/en-US/docs/Web/Manifest/categories>\n\n@docs toString, Category\n\n@docs books, business, education, entertainment, finance, fitness, food, games, government, health, kids, lifestyle, magazines, medical, music, navigation, news, personalization, photo, politics, productivity, security, shopping, social, sports, travel, utilities, weather\n\n\n## Custom categories\n\n@docs custom\n\n","unions":[{"name":"Category","comment":" Represents a known, valid category, as specified by\n<https://github.com/w3c/manifest/wiki/Categories>. If this document is updated\nand I don't add it, please open an issue or pull request to let me know!\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"books","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"business","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"custom","comment":" It's best to use the pre-defined categories to ensure that clients (Android, iOS,\nChrome, Windows app store, etc.) are aware of it and can handle it appropriately.\nBut, if you're confident about using a custom one, you can do so with `Pages.Manifest.custom`.\n","type":"String.String -> Pages.Manifest.Category.Category"},{"name":"education","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"entertainment","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"finance","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"fitness","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"food","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"games","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"government","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"health","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"kids","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"lifestyle","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"magazines","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"medical","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"music","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"navigation","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"news","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"personalization","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"photo","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"politics","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"productivity","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"security","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"shopping","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"social","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"sports","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"toString","comment":" Turn a category into its official String representation, as seen\nhere: <https://github.com/w3c/manifest/wiki/Categories>.\n","type":"Pages.Manifest.Category.Category -> String.String"},{"name":"travel","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"utilities","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"},{"name":"weather","comment":" Creates the described category.\n","type":"Pages.Manifest.Category.Category"}],"binops":[]},{"name":"Pages.PageUrl","comment":"\n\n@docs PageUrl, toUrl\n\n","unions":[],"aliases":[{"name":"PageUrl","comment":" ","args":[],"type":"{ protocol : Url.Protocol, host : String.String, port_ : Maybe.Maybe Basics.Int, path : Path.Path, query : Maybe.Maybe QueryParams.QueryParams, fragment : Maybe.Maybe String.String }"}],"values":[{"name":"toUrl","comment":" ","type":"Pages.PageUrl.PageUrl -> Url.Url"}],"binops":[]},{"name":"Pages.Secrets","comment":" Secrets are a secure way to use environment variables in your StaticHttp requests. The actual environment\nvariable value is used to perform StaticHttp requests, while the masked value is the only thing that ends up in your\nbuilt site. Let's go through what happens in a concrete example:\n\n\n## Example\n\nLet's say you execute this from the shell:\n\n```shell\nGITHUB_TOKEN=abcd1234 API_KEY=xyz789 elm-pages build\n```\n\nAnd your StaticHttp request in your Elm code looks like this:\n\n    import Pages.Secrets as Secrets\n    import DataSource\n\n    StaticHttp.request\n        (Secrets.succeed\n            (\\apiKey githubToken ->\n                { url = \"https://api.github.com/repos/dillonkearns/elm-pages?apiKey=\" ++ apiKey\n                , method = \"GET\"\n                , headers = [ ( \"Authorization\", \"Bearer \" ++ githubToken ) ]\n                }\n            )\n            |> Secrets.with \"API_KEY\"\n            |> Secrets.with \"BEARER\"\n        )\n        (Decode.succeed ())\n    )\n\nThe following masked values are what will be visible in your production bundle if you inspect the code or the Network tab:\n\n    [GET]https://api.github.com/repos/dillonkearns/elm-pages?apiKey=<API_KEY>Authorization : Bearer <BEARER>\n\nSo the actual Secrets only exist for the duration of the build in order to perform the StaticHttp requests, but they\nare replaced with `<SECRET_NAME>` once that step is done and your assets are bundled.\n\n@docs Value, map, succeed, with\n\n","unions":[],"aliases":[{"name":"Value","comment":" Represents a Secure value from your environment variables. `Pages.Secrets.Value`s are much like `Json.Decode.Value`s\nin that you can take raw values, map them, and combine them with other values into any data structure.\n","args":["value"],"type":"Secrets.Value value"}],"values":[{"name":"map","comment":" Map a Secret's raw value into an arbitrary type or value.\n","type":"(valueA -> valueB) -> Pages.Secrets.Value valueA -> Pages.Secrets.Value valueB"},{"name":"succeed","comment":" Hardcode a secret value. Or, this can be used to start a pipeline-style value with several different secrets (see\nthe example at the top of this page).\n\n    import Pages.Secrets as Secrets\n\n    Secrets.succeed \"hardcoded-secret\"\n\n","type":"value -> Pages.Secrets.Value value"},{"name":"with","comment":" Allows you to chain together multiple secrets. See the top of this page for a full example.\n","type":"String.String -> Pages.Secrets.Value (String.String -> value) -> Pages.Secrets.Value value"}],"binops":[]},{"name":"Pages.Url","comment":" Some of the `elm-pages` APIs will take internal URLs and ensure that they have the `canonicalSiteUrl` prepended.\n\nThat's the purpose for this type. If you have an external URL, like `Pages.Url.external \"https://google.com\"`,\nthen the canonicalUrl will not be prepended when it is used in a head tag.\n\nIf you refer to a local page, like `Route.Index {} |> Route.toPath |> Pages.Url.fromPath`, or `Pages.Url.fromPath`\n\n@docs Url, external, fromPath, toAbsoluteUrl, toString\n\n","unions":[{"name":"Url","comment":" ","args":[],"cases":[]}],"aliases":[],"values":[{"name":"external","comment":" ","type":"String.String -> Pages.Url.Url"},{"name":"fromPath","comment":" ","type":"Path.Path -> Pages.Url.Url"},{"name":"toAbsoluteUrl","comment":" ","type":"String.String -> Pages.Url.Url -> String.String"},{"name":"toString","comment":" ","type":"Pages.Url.Url -> String.String"}],"binops":[]},{"name":"Path","comment":" Represents the path portion of a URL (not query parameters, fragment, protocol, port, etc.).\n\nThis helper lets you combine together path parts without worrying about having too many or too few slashes.\nThese two examples will result in the same URL, even though the first example has trailing and leading slashes, and the\nsecond does not.\n\n    join [ \"/blog/\", \"/post-1/\" ]\n        |> Path.toAbsolute\n    --> \"/blog/post-1\"\n\n    join [ \"blog\", \"post-1\" ]\n        |> Path.toAbsolute\n    --> \"/blog/post-1\"\n\n\n## Creating Paths\n\n@docs Path, join, fromString\n\n\n## Turning Paths to String\n\n@docs toAbsolute, toRelative, toSegments\n\n","unions":[{"name":"Path","comment":" The path portion of the URL, normalized to ensure that path segments are joined with `/`s in the right places (no doubled up or missing slashes).\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"fromString","comment":" Create a Path from a path String.\n\n    Path.fromString \"blog/post-1/\"\n        |> Path.toAbsolute\n        |> Expect.equal \"/blog/post-1\"\n\n","type":"String.String -> Path.Path"},{"name":"join","comment":" Create a Path from multiple path parts. Each part can either be a single path segment, like `blog`, or a\nmulti-part path part, like `blog/post-1`.\n","type":"List.List String.String -> Path.Path"},{"name":"toAbsolute","comment":" Turn a Path to an absolute URL (with no trailing slash).\n","type":"Path.Path -> String.String"},{"name":"toRelative","comment":" Turn a Path to a relative URL.\n","type":"Path.Path -> String.String"},{"name":"toSegments","comment":" ","type":"Path.Path -> List.List String.String"}],"binops":[]},{"name":"QueryParams","comment":"\n\n@docs QueryParams\n\n\n## Parsing\n\n@docs Parser\n\n@docs andThen, fail, fromResult, fromString, optionalString, parse, string, strings, succeed\n\n\n## Combining\n\n@docs map2, oneOf\n\n\n## Accessing as Built-In Types\n\n@docs toDict, toString\n\n","unions":[{"name":"Parser","comment":" ","args":["a"],"cases":[]},{"name":"QueryParams","comment":" ","args":[],"cases":[]}],"aliases":[],"values":[{"name":"andThen","comment":" ","type":"(a -> QueryParams.Parser b) -> QueryParams.Parser a -> QueryParams.Parser b"},{"name":"fail","comment":" ","type":"String.String -> QueryParams.Parser a"},{"name":"fromResult","comment":" ","type":"Result.Result String.String a -> QueryParams.Parser a"},{"name":"fromString","comment":" ","type":"String.String -> QueryParams.QueryParams"},{"name":"map2","comment":" ","type":"(a -> b -> combined) -> QueryParams.Parser a -> QueryParams.Parser b -> QueryParams.Parser combined"},{"name":"oneOf","comment":" ","type":"List.List (QueryParams.Parser a) -> QueryParams.Parser a"},{"name":"optionalString","comment":" ","type":"String.String -> QueryParams.Parser (Maybe.Maybe String.String)"},{"name":"parse","comment":" ","type":"QueryParams.Parser a -> QueryParams.QueryParams -> Result.Result String.String a"},{"name":"string","comment":" ","type":"String.String -> QueryParams.Parser String.String"},{"name":"strings","comment":" ","type":"String.String -> QueryParams.Parser (List.List String.String)"},{"name":"succeed","comment":" ","type":"a -> QueryParams.Parser a"},{"name":"toDict","comment":" ","type":"QueryParams.QueryParams -> Dict.Dict String.String (List.List String.String)"},{"name":"toString","comment":" ","type":"QueryParams.QueryParams -> String.String"}],"binops":[]}]